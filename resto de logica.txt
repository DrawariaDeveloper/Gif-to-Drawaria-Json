class AdvancedPhysicsTool extends QBit {
    // Propiedades del módulo y del motor de física
    _canvas = null;
    _ctx = null;
    _isActive = false;
    _physicsObjects = new Map();
    _objectIdCounter = 0;
    _lastRenderTime = 0;
    _renderInterval = 1000 / 30;
    _rainbowHue = 0;
    _rainbowInterval = null;
    _lastAutoKick = 0;

    // Sistema de notificaciones, arrastre y WebSocket
    _gameSocket = null;
    _commandQueue = [];
    _batchProcessor = null;
    _isDragging = false;
    _dragOffset = { x: 0, y: 0 };
    _uiElements = {};

    // Controles y modos de juego
    controls = {
        showTrails: false,
        showDebug: false,
        rainbowModeActive: false,
        defaultObjectColor: '#000000',
        autoKickEnabled: false,
    };
    matchMode = {
        active: false,
        scores: { p1: 0, p2: 0 },
        goalCooldown: false,
    };
    playerTracker = {
        players: new Map(),
        detectionRadius: 40 * 1.3,
        lastUpdateTime: 0
    };

    constructor() {
        super("Advanced Physics", '<i class="fas fa-futbol"></i>');
    }

    // Método de inicialización de Cubic Engine
    _onStartup() {
        this.notify("info", "Iniciando motor de física...");
        this._findGameCanvas();
        this._setupWebSocketCapture();
        this._startBatchProcessor();
        this._startPhysicsLoop();
        this.notify("success", "Motor de física inicializado.");
        setTimeout(() => {
            this.addBallAtCenter();
        }, 500);
    }

    // Método para cargar la interfaz de usuario
    _loadInterface() {
        this._createPhysicsPanel();
        this._setupEventListeners();
        this._makePanelDraggable();
    }

    // Método de limpieza al cerrar el módulo
    _cleanup() {
        this.notify("info", "Cerrando motor de física...");
        this._stopPhysicsLoop();
        this._stopBatchProcessor();
        if (this._rainbowInterval) {
            clearInterval(this._rainbowInterval);
            this._rainbowInterval = null;
        }
        const panel = document.getElementById("advanced-physics-panel");
        if (panel && panel.parentNode) {
            panel.parentNode.removeChild(panel);
        }
        if (this._ctx && this._canvas) {
            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        }
        this._physicsObjects.clear();
    }

    // --- LÓGICA COMPLETA DEL MOTOR DE FÍSICA ---

    // ✅ REEMPLAZAR _findGameCanvas() para Cubic Engine:
_findGameCanvas() {
    // ✅ Múltiples estrategias de detección para Cubic Engine
    this._canvas = document.querySelector("#drawing-assistant-overlay") ||
                  document.getElementById('canvas') ||
                  document.querySelector('canvas') ||
                  document.querySelector('#game-canvas');
                  
    if (this._canvas) {
        this._ctx = this._canvas.getContext('2d');
        this.notify("success", "Canvas del juego encontrado.");
    } else {
        this.notify("error", "Canvas del juego no encontrado.");
    }
}

_setupWebSocketCapture() {
    const self = this; // ✅ Guardar referencia correcta
    const originalWebSocketSend = WebSocket.prototype.send;
    
    WebSocket.prototype.send = function(...args) {
        // ✅ Captura correcta del WebSocket
        if (!this._physicsCaptured && this.url && this.url.includes('drawaria')) {
            this._physicsCaptured = true;
            self._gameSocket = this; // ✅ Ahora 'self' se refiere al módulo
            console.log('🔗 WebSocket capturado para motor de física');
        }
        return originalWebSocketSend.apply(this, args);
    };
}

    _createPhysicsPanel() {
        const panel = document.createElement("div");
        panel.id = "advanced-physics-panel";
        panel.style.cssText = `
            position: fixed;
            top: 10px;
            left: 10px;
            width: 250px;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 1000;
            background-color: #ffffff;
            color: #000000;
            font-family: Arial, sans-serif;
        `;

        const header = document.createElement("div");
        header.id = "panel-header";
        header.innerText = "Physics Controls";
        header.style.cssText = `
            padding: 8px 12px;
            background-color: #f0f0f0;
            border-bottom: 1px solid #ccc;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            font-weight: bold;
            cursor: move;
            user-select: none;
        `;
        panel.appendChild(header);

        const content = document.createElement("div");
        content.id = "panel-content";
        content.style.padding = "10px";
        panel.appendChild(content);

        const createControlRow = (label, id) => {
            const row = document.createElement("div");
            row.className = "control-row";
            row.style.cssText = "display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;";
            const labelElement = document.createElement("label");
            labelElement.innerText = label;
            labelElement.htmlFor = id;
            labelElement.style.marginRight = "10px";
            row.appendChild(labelElement);
            const input = document.createElement("input");
            input.type = "checkbox";
            input.id = id;
            row.appendChild(input);
            return row;
        };

        const createFieldBtn = (text, id, bgColor) => {
            const btn = document.createElement("button");
            btn.id = id;
            btn.innerText = text;
            btn.style.cssText = `
                width: 100%;
                padding: 8px;
                margin-bottom: 5px;
                background-color: ${bgColor};
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            `;
            return btn;
        };

        content.appendChild(createControlRow("Show Debug", "debug-toggle"));
        content.appendChild(createControlRow("Show Trails", "trails-toggle"));
        content.appendChild(createControlRow("Rainbow Mode", "rainbow-toggle"));

        const fieldSection = document.createElement("div");
        fieldSection.style.cssText = "margin-top: 15px; padding-top: 10px; border-top: 1px dashed #ccc;";
        const fieldHeader = document.createElement("h4");
        fieldHeader.innerText = "Field Controls";
        fieldHeader.style.margin = "0 0 10px 0";
        fieldSection.appendChild(fieldHeader);

        fieldSection.appendChild(createFieldBtn("Create Field", "create-field-btn", "#007bff"));
        fieldSection.appendChild(createFieldBtn("Clear Field", "clear-field-btn", "#007bff"));
        fieldSection.appendChild(createFieldBtn("Toggle Match Mode", "match-mode-btn", "#ff6b35"));
        fieldSection.appendChild(createFieldBtn("Toggle Auto-Kick", "auto-kick-btn", "#6c5ce7"));
        fieldSection.appendChild(createFieldBtn("Add Ball", "add-ball-btn", "#00b894"));

        content.appendChild(fieldSection);
        document.body.appendChild(panel);
    }

    _setupEventListeners() {
        document.getElementById("debug-toggle").addEventListener('change', (e) => this.controls.showDebug = e.target.checked);
        document.getElementById("trails-toggle").addEventListener('change', (e) => this.controls.showTrails = e.target.checked);
        document.getElementById("rainbow-toggle").addEventListener('change', (e) => {
            this.controls.rainbowModeActive = e.target.checked;
            this.toggleRainbowMode(e.target.checked);
        });
        document.getElementById("create-field-btn").addEventListener('click', () => this.createFootballField());
        document.getElementById("clear-field-btn").addEventListener('click', () => this.clearField());
        document.getElementById("match-mode-btn").addEventListener('click', () => this.toggleMatchMode());
        document.getElementById("auto-kick-btn").addEventListener('click', () => this.toggleAutoKick());
        document.getElementById("add-ball-btn").addEventListener('click', () => this.addBallAtCenter());
    }

    _startPhysicsLoop() {
        if (this._isActive) return;
        this._isActive = true;
        this._lastAutoKick = 0;
        console.log("🚀 Iniciando loop de física...");
        this._update(performance.now());
    }

    _stopPhysicsLoop() {
        this._isActive = false;
        console.log("🛑 Loop de física detenido");
    }

    _update(currentTime) {
        if (!this._isActive) return;

        const deltaTime = (currentTime - this._lastRenderTime) / 1000;
        if (deltaTime < this._renderInterval / 1000) {
            requestAnimationFrame(this._update.bind(this));
            return;
        }
        this._lastRenderTime = currentTime;

        this._physicsObjects.forEach(obj => {
            obj.velocity.y += obj.gravity * deltaTime;
            obj.velocity.x *= obj.friction;
            obj.velocity.y *= obj.friction;
            obj.position.x += obj.velocity.x;
            obj.position.y += obj.velocity.y;
        });

        this._checkCollisions();
        this._checkGoals();
        this._drawObjects();
        this._checkAutoKick();

        requestAnimationFrame(this._update.bind(this));
    }

    _checkCollisions() {
        const gameWidth = 100;
        const gameHeight = 100;
        this._physicsObjects.forEach(obj => {
            if (obj.position.x - obj.radius < 0) {
                obj.velocity.x = -obj.velocity.x * 0.8;
                obj.position.x = obj.radius;
            }
            if (obj.position.x + obj.radius > gameWidth) {
                obj.velocity.x = -obj.velocity.x * 0.8;
                obj.position.x = gameWidth - obj.radius;
            }
            if (obj.position.y - obj.radius < 0) {
                obj.velocity.y = -obj.velocity.y * 0.8;
                obj.position.y = obj.radius;
            }
            if (obj.position.y + obj.radius > gameHeight) {
                obj.velocity.y = -obj.velocity.y * 0.8;
                obj.position.y = gameHeight - obj.radius;
            }

            this._physicsObjects.forEach(otherObj => {
                if (obj.id === otherObj.id) return;
                const dx = otherObj.position.x - obj.position.x;
                const dy = otherObj.position.y - obj.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDistance = obj.radius + otherObj.radius;
                if (distance < minDistance) {
                    const angle = Math.atan2(dy, dx);
                    const overlap = minDistance - distance;
                    obj.position.x -= (overlap / 2) * Math.cos(angle);
                    obj.position.y -= (overlap / 2) * Math.sin(angle);
                    otherObj.position.x += (overlap / 2) * Math.cos(angle);
                    otherObj.position.y += (overlap / 2) * Math.sin(angle);
                    const v1 = { x: obj.velocity.x, y: obj.velocity.y };
                    const v2 = { x: otherObj.velocity.x, y: otherObj.velocity.y };
                    obj.velocity.x = v2.x;
                    obj.velocity.y = v2.y;
                    otherObj.velocity.x = v1.x;
                    otherObj.velocity.y = v1.y;
                }
            });

            this._updatePlayerDetection();
            this.playerTracker.players.forEach(p => {
                const dx = p.x - obj.position.x;
                const dy = p.y - obj.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const radius = obj.radius;
                if (distance < radius + p.radius) {
                    const angle = Math.atan2(dy, dx);
                    const impactForce = 0.5;
                    obj.velocity.x -= impactForce * Math.cos(angle);
                    obj.velocity.y -= impactForce * Math.sin(angle);
                }
            });
        });
    }

    addObject(objectData) {
        if (objectData.type !== 'ball') return;
        const newId = this._objectIdCounter++;
        const newObject = {
            id: newId,
            type: objectData.type,
            position: { x: objectData.x, y: objectData.y },
            velocity: { x: 0, y: 0 },
            gravity: 0.05,
            friction: 0.98,
            radius: objectData.radius,
            color: objectData.color || this.controls.defaultObjectColor,
            trail: this.controls.showTrails ? [] : null,
        };
        this._physicsObjects.set(newId, newObject);
        return newObject;
    }

    _drawObjects() {
        const { _ctx: ctx, _canvas: canvas } = this;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const widthRatio = canvas.width / 100;
        const heightRatio = canvas.height / 100;
        this._physicsObjects.forEach(obj => {
            if (this.controls.showTrails && obj.trail) {
                obj.trail.push({
                    x: obj.position.x * widthRatio,
                    y: obj.position.y * heightRatio,
                    color: obj.color
                });
                while (obj.trail.length > 50) obj.trail.shift();
                obj.trail.forEach((point, index) => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, obj.radius * widthRatio * (index / 50), 0, 2 * Math.PI);
                    ctx.fillStyle = point.color;
                    ctx.globalAlpha = index / 50;
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }
            ctx.beginPath();
            ctx.arc(obj.position.x * widthRatio, obj.position.y * heightRatio, obj.radius * widthRatio, 0, 2 * Math.PI);
            ctx.fillStyle = obj.color;
            ctx.fill();
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.stroke();
            if (this.controls.showDebug) {
                ctx.fillStyle = 'red';
                ctx.font = '12px Arial';
                ctx.fillText(`ID: ${obj.id}`, obj.position.x * widthRatio, obj.position.y * heightRatio - 15);
                ctx.fillText(`Vel: (${obj.velocity.x.toFixed(2)}, ${obj.velocity.y.toFixed(2)})`, obj.position.x * widthRatio - 20, obj.position.y * heightRatio);
            }
        });
    }

    toggleMatchMode() {
        this.matchMode.active = !this.matchMode.active;
        if (this.matchMode.active) {
            this.notify("info", "Modo Partido Activado.");
            this.createFootballField();
            this._physicsObjects.clear();
            this.addBallAtCenter();
            this.matchMode.scores = { p1: 0, p2: 0 };
        } else {
            this.notify("info", "Modo Partido Desactivado.");
            this.clearField();
        }
    }

    _checkGoals() {
        if (!this.matchMode.active || this.matchMode.goalCooldown) return;
        const ball = Array.from(this._physicsObjects.values()).find(obj => obj.type === 'ball');
        if (!ball) return;
        const goalSize = 10;
        const goal1X = 0;
        const goal2X = 100;
        const p1Goal = ball.position.x <= goal1X && ball.position.y > 50 - goalSize / 2 && ball.position.y < 50 + goalSize / 2;
        const p2Goal = ball.position.x >= goal2X && ball.position.y > 50 - goalSize / 2 && ball.position.y < 50 + goalSize / 2;
        if (p1Goal) {
            this._scoreGoal('p2');
        } else if (p2Goal) {
            this._scoreGoal('p1');
        }
    }

    _scoreGoal(scoringPlayer) {
        this.matchMode.scores[scoringPlayer]++;
        this.notify("success", `¡GOL! Puntuación: P1 - ${this.matchMode.scores.p1} | P2 - ${this.matchMode.scores.p2}`);
        this.matchMode.goalCooldown = true;
        setTimeout(() => {
            this.matchMode.goalCooldown = false;
            this._resetBall();
        }, 3000);
    }

    _resetBall() {
        this._physicsObjects.forEach(obj => {
            if (obj.type === 'ball') {
                obj.position.x = 50;
                obj.position.y = 50;
                obj.velocity.x = 0;
                obj.velocity.y = 0;
            }
        });
    }

    createFootballField() {
        const fieldCommands = [
            { x1: 5, y1: 10, x2: 5, y2: 90 },
            { x1: 95, y1: 10, x2: 95, y2: 90 },
            { x1: 5, y1: 10, x2: 95, y2: 10 },
            { x1: 5, y1: 90, x2: 95, y2: 90 },
            { x1: 50, y1: 10, x2: 50, y2: 90 },
            { x1: 50, y1: 50, x2: 50, y2: 50, radius: 10 },
            { x1: 5, y1: 30, x2: 25, y2: 30 },
            { x1: 25, y1: 30, x2: 25, y2: 70 },
            { x1: 25, y1: 70, x2: 5, y2: 70 },
            { x1: 95, y1: 30, x2: 75, y2: 30 },
            { x1: 75, y1: 30, x2: 75, y2: 70 },
            { x1: 75, y1: 70, x2: 95, y2: 70 },
            { x1: 25, y1: 50, x2: 25, y2: 50, radius: 5 },
            { x1: 75, y1: 50, x2: 75, y2: 50, radius: 5 },
        ];
        const drawCommands = {
            "type": "draw",
            "lines": fieldCommands.map(cmd => ({
                "start": { "x": cmd.x1, "y": cmd.y1 },
                "end": { "x": cmd.x2, "y": cmd.y2 },
                "color": "#ffffff",
                "thickness": 3
            }))
        };
        this.enviarComandoDibujo(drawCommands);
    }

    clearField() {
        this.enviarComandoDibujo({ "type": "clear" });
    }

    toggleRainbowMode(active) {
        if (active) {
            this._rainbowInterval = setInterval(() => {
                this._rainbowHue = (this._rainbowHue + 1) % 360;
                this.controls.defaultObjectColor = `hsl(${this._rainbowHue}, 100%, 50%)`;
            }, 50);
        } else {
            clearInterval(this._rainbowInterval);
            this._rainbowInterval = null;
            this.controls.defaultObjectColor = '#000000';
        }
    }

    _checkAutoKick() {
        if (!this.controls.autoKickEnabled) return;
        const now = performance.now();
        if (now - this._lastAutoKick < 2000) return;
        const ball = Array.from(this._physicsObjects.values()).find(obj => obj.type === 'ball');
        if (!ball) return;
        const isCloserToLeftGoal = ball.position.x < 50;
        const targetGoalX = isCloserToLeftGoal ? 95 : 5;
        const targetGoalY = 50;
        const dx = targetGoalX - ball.position.x;
        const dy = targetGoalY - ball.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance > 0) {
            const kickForce = 0.8;
            ball.velocity.x += (dx / distance) * kickForce;
            ball.velocity.y += (dy / distance) * kickForce;
            this._lastAutoKick = now;
        }
    }

    _makePanelDraggable() {
        const panel = document.getElementById("advanced-physics-panel");
        const header = document.getElementById("panel-header");
        header.addEventListener('mousedown', (e) => {
            this._isDragging = true;
            this._dragOffset.x = e.clientX - panel.offsetLeft;
            this._dragOffset.y = e.clientY - panel.offsetTop;
            panel.style.cursor = 'grabbing';
            e.preventDefault();
        });
        document.addEventListener('mousemove', (e) => {
            if (this._isDragging) {
                const newLeft = e.clientX - this._dragOffset.x;
                const newTop = e.clientY - this._dragOffset.y;
                const maxLeft = window.innerWidth - panel.offsetWidth;
                const maxTop = window.innerHeight - panel.offsetHeight;
                panel.style.left = Math.min(Math.max(0, newLeft), maxLeft) + 'px';
                panel.style.top = Math.min(Math.max(0, newTop), maxTop) + 'px';
            }
        });
        document.addEventListener('mouseup', () => {
            if (this._isDragging) {
                this._isDragging = false;
                panel.style.cursor = 'default';
            }
        });
    }

    toggleAutoKick() {
        this.controls.autoKickEnabled = !this.controls.autoKickEnabled;
        this._lastAutoKick = 0;
        const message = this.controls.autoKickEnabled ?
            "🤖 Auto-Kick Activado" : "🤖 Auto-Kick Desactivado";
        this.notify("info", message);
    }

    addBallAtCenter() {
        const newBall = this.addObject({
            type: 'ball',
            x: 50,
            y: 50,
            radius: 2,
            color: this.controls.rainbowModeActive ?
                `hsl(${this._rainbowHue}, 100%, 50%)` :
                this.controls.defaultObjectColor
        });
        if (newBall) {
            this.notify("success", "Pelota agregada al juego");
        }
    }

    enviarComandoDibujo(drawCommands) {
        if (!this._gameSocket || this._gameSocket.readyState !== WebSocket.OPEN) {
            this.notify("error", "WebSocket no disponible para enviar comando de dibujo");
            return;
        }
        if (drawCommands.type === "draw") {
            drawCommands.lines.forEach(line => {
                const x1 = (line.start.x / 100) * this._canvas.width;
                const y1 = (line.start.y / 100) * this._canvas.height;
                const x2 = (line.end.x / 100) * this._canvas.width;
                const y2 = (line.end.y / 100) * this._canvas.height;
                this._enqueueDrawCommand(x1, y1, x2, y2, line.color, line.thickness);
            });
        } else if (drawCommands.type === "clear") {
            this._sendClearCommand();
        }
    }

    _updatePlayerDetection() {
        const now = performance.now();
        if (now - this.playerTracker.lastUpdateTime < 100) return;
        this.playerTracker.players.clear();
        try {
            const selfPlayer = document.querySelector('.spawnedavatar.spawnedavatar-self');
            if (selfPlayer) {
                const rect = selfPlayer.getBoundingClientRect();
                const canvasRect = this._canvas.getBoundingClientRect();
                this.playerTracker.players.set('self', {
                    id: 'self',
                    x: ((rect.left - canvasRect.left) / canvasRect.width) * 100,
                    y: ((rect.top - canvasRect.top) / canvasRect.height) * 100,
                    radius: 3,
                    type: 'self'
                });
            }
            const otherPlayers = document.querySelectorAll('.spawnedavatar.spawnedavatar-otherplayer');
            otherPlayers.forEach((player, index) => {
                const rect = player.getBoundingClientRect();
                const canvasRect = this._canvas.getBoundingClientRect();
                this.playerTracker.players.set(`other_${index}`, {
                    id: `other_${index}`,
                    x: ((rect.left - canvasRect.left) / canvasRect.width) * 100,
                    y: ((rect.top - canvasRect.top) / canvasRect.height) * 100,
                    radius: 3,
                    type: 'other'
                });
            });
        } catch (e) {
            console.warn("Error detectando jugadores:", e);
        }
        this.playerTracker.lastUpdateTime = now;
    }

    // --- FUNCIONES NUEVAS Y CORREGIDAS ---

    _startBatchProcessor() {
        if (this._batchProcessor) return;
        const BATCH_INTERVAL = 45; // 45ms = ~22 FPS
        this._batchProcessor = setInterval(() => {
            this._flushCommandQueue();
        }, BATCH_INTERVAL);
        console.log("🔄 Batch processor iniciado");
    }

    _stopBatchProcessor() {
        if (this._batchProcessor) {
            clearInterval(this._batchProcessor);
            this._batchProcessor = null;
            this._flushCommandQueue(); // Final flush antes de detener
            console.log("⏹️ Batch processor detenido");
        }
    }

    _enqueueDrawCommand(x1, y1, x2, y2, color, thickness) {
        if (!this._canvas || !this._gameSocket || this._gameSocket.readyState !== WebSocket.OPEN) {
            console.warn("Canvas o WebSocket no disponible para comando de dibujo");
            return;
        }

        const normX1 = (x1 / this._canvas.width);
        const normY1 = (y1 / this._canvas.height);
        const normX2 = (x2 / this._canvas.width);
        const normY2 = (y2 / this._canvas.height);

        const cmd = `42["drawcmd",0,[${normX1},${normY1},${normX2},${normY2},false,${-Math.abs(thickness)},"${color}",0,0,{}]]`;
        this._commandQueue.push(cmd);

        if (this._ctx) {
            this._ctx.strokeStyle = color;
            this._ctx.lineWidth = thickness;
            this._ctx.lineCap = 'round';
            this._ctx.lineJoin = 'round';
            this._ctx.beginPath();
            this._ctx.moveTo(x1, y1);
            this._ctx.lineTo(x2, y2);
            this._ctx.stroke();
        }

        if (this._commandQueue.length >= 15) {
            this._flushCommandQueue();
        }
    }

    _flushCommandQueue() {
        if (this._commandQueue.length === 0) return;

        const BATCH_SIZE = 12;
        const batch = this._commandQueue.splice(0, BATCH_SIZE);
        batch.forEach(cmd => {
            try {
                this._gameSocket.send(cmd);
            } catch (e) {
                console.warn('Failed to send physics command:', e);
            }
        });
    }

    _sendClearCommand() {
        if (!this._gameSocket || this._gameSocket.readyState !== WebSocket.OPEN) {
            console.warn("WebSocket no disponible para comando de limpieza");
            return false;
        }

        try {
            const clearCmd = `42["clear",0]`;
            this._gameSocket.send(clearCmd);
            if (this._ctx && this._canvas) {
                this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
            }
            this._commandQueue.length = 0;
            console.log("🧹 Canvas cleared successfully");
            return true;
        } catch (e) {
            console.error("Error al enviar comando de limpieza:", e);
            this.notify("error", "Error al limpiar canvas");
            return false;
        }
    }
}

// 1. Cargar el módulo en Cubic Engine
this.loadExtension(AdvancedPhysicsTool);
