class AdvancedPhysicsTool extends QBit {
    _canvas = null;
    _ctx = null;
    _isActive = false;
    _physicsObjects = new Map();
    _objectIdCounter = 0;
    _lastRenderTime = 0;
    _renderInterval = 1000 / 60;
    _gameSocket = null;
    _ui = {};
    _statsInterval = null;

    // Constantes de f√≠sica simplificadas
    PHYSICS_CONSTANTS = {
        GRAVITY: 500,
        BALL_MASS: 0.25,
        BALL_RADIUS: 40,
        TIMESTEP: 1 / 60,
        MAX_VELOCITY: 800,
        AIR_RESISTANCE: 0.008,
        RESTITUTION_BALL: 0.75,
        RESTITUTION_WALL: 0.6,
        FRICTION_GRASS: 0.85
    };

    // Constantes del campo
    FIELD_CONSTANTS = {
        GOAL_P1_COLOR: '#555555',
        GOAL_P2_COLOR: '#787878',
        TEXT_COLOR: '#000000',
        GRASS_COLOR: '#228B22',
        GOAL_THICKNESS: 10
    };

    // Sistema de match simplificado
    matchMode = {
        active: false,
        scores: { p1: 0, p2: 0 },
        playArea: null,
        goalCooldown: false,
        maxGoals: 5
    };

    controls = {
        showTrails: false,
        defaultObjectColor: '#000000',
        alternatePhysics: 'normal'
    };

    gameStats = {
        totalCollisions: 0,
        maxVelocityReached: 0,
        objectsCreated: 0,
        totalGoals: 0
    };

    constructor() {
        super("Football Physics Engine v6.0", '<i class="fas fa-futbol"></i>');
        this._onStartup();
    }

    _onStartup() {
        this.notify("info", "üöÄ Iniciando motor de f√∫tbol...");
        this._findGameCanvas();
        this._setupWebSocketCapture();
        this._loadInterface();
        this._startAdvancedStatsMonitoring();
        this.notify("success", "‚öΩ Motor de f√∫tbol inicializado y listo.");
    }

    _onClose() {
        this.notify("info", "üîÑ Cerrando motor de f√≠sica...");
        this._stopPhysicsLoop();
        this._stopAdvancedStatsMonitoring();
        this._physicsObjects.clear();
        this._ctx?.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this.notify("success", "‚úÖ Motor cerrado correctamente.");
    }

    _loadInterface() {
        if (this._ui.panel) {
            this._ui.panel.remove();
        }

        const container = domMake.Tree("div", {
            id: `${this.identifier}-container`,
            style: `
                display: flex; flex-direction: column; gap: 10px;
                padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3); color: white;
            `
        });
        this._ui.panel = container;
        this.htmlElements.section.appendChild(container);

        // T√≠tulo
        container.appendChild(domMake.Tree("h3", { 
            style: "margin: 0; font-size: 16px; text-align: center;" 
        }, "‚öΩ FOOTBALL PHYSICS v6.0"));

        // Controles principales
        const controlsDiv = domMake.Tree("div", { 
            style: "display: flex; flex-direction: column; gap: 8px;" 
        });

        // Bot√≥n crear campo
        const createFieldBtn = domMake.Tree("button", {
            id: this.identifier + '-create-field-btn',
            style: `width: 100%; padding: 12px; background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;`
        }, "üèüÔ∏è Create Football Field");

        // Bot√≥n toggle physics
        const togglePhysicsBtn = domMake.Tree("button", {
            id: this.identifier + '-toggle-physics',
            style: `width: 100%; padding: 12px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;`
        }, "üöÄ Launch Physics Engine");

        controlsDiv.appendChild(createFieldBtn);
        controlsDiv.appendChild(togglePhysicsBtn);

        // Controles de objetos
        const ballControlsDiv = domMake.Tree("div", {
            style: "display: flex; gap: 8px;"
        });
        
        const addBallBtn = domMake.Tree("button", {
            id: this.identifier + '-add-ball-btn',
            style: `flex: 1; padding: 10px; background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;`
        }, "‚öΩ Add Ball");

        const resetAllBtn = domMake.Tree("button", {
            id: this.identifier + '-reset-all-btn',
            style: `flex: 1; padding: 10px; background: linear-gradient(135deg, #f1c40f, #f39c12); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;`
        }, "üîÑ Reset");

        ballControlsDiv.appendChild(addBallBtn);
        ballControlsDiv.appendChild(resetAllBtn);
        controlsDiv.appendChild(ballControlsDiv);

        // Match Mode Toggle
        const matchModeToggle = domMake.Tree("button", {
            id: this.identifier + '-match-mode-toggle',
            style: `width: 100%; padding: 12px; background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;`
        }, "üèÜ Match Mode");
        controlsDiv.appendChild(matchModeToggle);

        // Limpiar todo
        const clearAllBtn = domMake.Tree("button", {
            id: this.identifier + '-clear-all-btn',
            style: `width: 100%; padding: 10px; background: linear-gradient(135deg, #7f8c8d, #34495e); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;`
        }, "üóëÔ∏è Clear All");
        controlsDiv.appendChild(clearAllBtn);

        container.appendChild(controlsDiv);

        // Marcador (oculto inicialmente)
        const scoreboard = domMake.Tree("div", {
            id: this.identifier + '-scoreboard',
            style: `display: none; text-align: center; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; font-weight: bold; font-size: 18px; background: rgba(0,0,0,0.4); border-radius: 8px; padding: 15px; border: 2px solid #ffd700;`
        });

        const scoreTitle = domMake.Tree("h4", { style: "margin: 0 0 10px 0; color: #ffd700; font-size: 14px;" }, "üèÜ MATCH SCORE");
        const scoreContainer = domMake.Tree("div", { style: "display: flex; justify-content: space-between; font-size: 18px; font-weight: bold;" });
        
        const scoreP1 = domMake.Tree("span", { id: this.identifier + '-score-p1', style: "color: #ff6b6b;" }, "0");
        const scoreP2 = domMake.Tree("span", { id: this.identifier + '-score-p2', style: "color: #74b9ff;" }, "0");
        
        scoreContainer.appendChild(domMake.Tree("span", {}, "P1: "));
        scoreContainer.appendChild(scoreP1);
        scoreContainer.appendChild(domMake.Tree("span", { style: "color: #666;" }, " vs "));
        scoreContainer.appendChild(domMake.Tree("span", {}, "P2: "));
        scoreContainer.appendChild(scoreP2);
        
        scoreboard.appendChild(scoreTitle);
        scoreboard.appendChild(scoreContainer);
        container.appendChild(scoreboard);

        // Estad√≠sticas
        const statsDiv = domMake.Tree("div", {
            id: this.identifier + '-stats',
            style: `font-size: 10px; text-align: center; color: #aaa; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px;`
        });
        const objectCount = domMake.Tree("span", { id: this.identifier + '-object-count' }, "0");
        const goalsCount = domMake.Tree("span", { id: this.identifier + '-goals-count' }, "0");
        const statsContainer = domMake.Tree("div", {});
        statsContainer.appendChild(domMake.Tree("span", {}, "Objects: "));
        statsContainer.appendChild(objectCount);
        statsContainer.appendChild(domMake.Tree("span", {}, " | Goals: "));
        statsContainer.appendChild(goalsCount);
        statsDiv.appendChild(statsContainer);
        container.appendChild(statsDiv);

        // Guardar referencias
        this._ui.createFieldBtn = createFieldBtn;
        this._ui.togglePhysicsBtn = togglePhysicsBtn;
        this._ui.addBallBtn = addBallBtn;
        this._ui.resetAllBtn = resetAllBtn;
        this._ui.matchModeToggle = matchModeToggle;
        this._ui.clearAllBtn = clearAllBtn;
        this._ui.scoreboard = scoreboard;
        this._ui.scoreP1 = scoreP1;
        this._ui.scoreP2 = scoreP2;
        this._ui.objectCount = objectCount;
        this._ui.goalsCount = goalsCount;

        // Event listeners
        this._ui.createFieldBtn?.addEventListener('click', () => this.createFootballField());
        this._ui.togglePhysicsBtn?.addEventListener('click', () => this.togglePhysics());
        this._ui.addBallBtn?.addEventListener('click', () => this.addBallAtCenter());
        this._ui.resetAllBtn?.addEventListener('click', () => this.resetAllObjects());
        this._ui.matchModeToggle?.addEventListener('click', () => this.toggleMatchMode());
        this._ui.clearAllBtn?.addEventListener('click', () => this.clearAllObjects());
    }

    _findGameCanvas() {
        this._canvas = document.getElementById('canvas') || document.querySelector('canvas');
        if (this._canvas) {
            this._ctx = this._canvas.getContext('2d');
            this.notify("success", "üéØ Canvas detectado.");
            return true;
        } else {
            this.notify("error", "‚ùå Canvas no encontrado.");
            return false;
        }
    }

    _setupWebSocketCapture() {
        if (typeof getGameSocket !== 'function') {
            this.notify("error", "‚ùå Funci√≥n getGameSocket no disponible.");
            return false;
        }
        
        this._gameSocket = getGameSocket();
        if (this._gameSocket && this._gameSocket.readyState === WebSocket.OPEN) {
            this.notify("success", "üåê WebSocket conectado.");
            return true;
        } else {
            this.notify("warning", "‚ö†Ô∏è WebSocket no disponible.");
            return false;
        }
    }

    // ‚úÖ M√âTODO DE DIBUJO OPTIMIZADO
    _sendDrawCommand(x1, y1, x2, y2, color, thickness) {
        if (!this._canvas) return false;
        
        const socket = getGameSocket();
        if (!socket || socket.readyState !== WebSocket.OPEN) {
            return false;
        }

        const normX1 = (x1 / this._canvas.width).toFixed(4);
        const normY1 = (y1 / this._canvas.height).toFixed(4);
        const normX2 = (x2 / this._canvas.width).toFixed(4);
        const normY2 = (y2 / this._canvas.height).toFixed(4);

        const command = `42["drawcmd",0,[${normX1},${normY1},${normX2},${normY2},false,${-Math.abs(thickness)},"${color}",0,0,{}]]`;
        
        try {
            socket.send(command);
        } catch (error) {
            return false;
        }

        // Renderizado local
        if (this._ctx) {
            this._ctx.strokeStyle = color;
            this._ctx.lineWidth = thickness;
            this._ctx.lineCap = 'round';
            this._ctx.lineJoin = 'round';
            this._ctx.beginPath();
            this._ctx.moveTo(x1, y1);
            this._ctx.lineTo(x2, y2);
            this._ctx.stroke();
        }
        
        return true;
    }

    // ‚úÖ CREAR CAMPO DE F√öTBOL
    async createFootballField() {
        if (!this._canvas) {
            this.notify("error", "‚ùå Canvas no disponible.");
            return;
        }

        this.notify("info", "üèüÔ∏è Creando campo de f√∫tbol...");
        
        // Limpiar canvas primero
        await this._cleanCanvas();
        await this._delay(200);

        // Calcular coordenadas del campo
        const fieldCoords = this._calculateFieldCoordinates();

        // Dibujar c√©sped
        await this._drawGrass(fieldCoords);
        await this._delay(300);

        // Dibujar porter√≠as
        await this._drawGoal(fieldCoords.leftGoal, this.FIELD_CONSTANTS.GOAL_P1_COLOR);
        await this._drawGoal(fieldCoords.rightGoal, this.FIELD_CONSTANTS.GOAL_P2_COLOR);
        await this._delay(300);

        // Dibujar texto FOOTBALL
        await this._drawFootballText(fieldCoords);

        this.notify("success", "üèÜ ¬°Campo creado correctamente!");
    }

    _calculateFieldCoordinates() {
        const width = this._canvas.width;
        const height = this._canvas.height;
        
        return {
            leftGoal: {
                x: Math.floor(width * -0.05),
                y: Math.floor(height * 0.67),
                width: Math.floor(width * 0.25),
                height: Math.floor(height * 0.42)
            },
            rightGoal: {
                x: Math.floor(width * 0.80),
                y: Math.floor(height * 0.67),
                width: Math.floor(width * 0.25),
                height: Math.floor(height * 0.42)
            },
            grass: {
                y: height - 2,
                triangleSpacing: Math.max(8, Math.floor(width * 0.015)),
                triangleHeight: Math.max(10, Math.floor(height * 0.025))
            },
            text: {
                x: Math.floor(width * 0.5),
                y: Math.floor(height * 0.15),
                pixelSize: Math.max(2, Math.floor(width * 0.006))
            }
        };
    }

    async _drawGrass(coords) {
        const width = this._canvas.width;
        const lineThickness = Math.max(4, Math.floor(width * 0.01));
        
        // L√≠nea principal del c√©sped
        this._sendDrawCommand(0, coords.grass.y, width, coords.grass.y, this.FIELD_CONSTANTS.GRASS_COLOR, lineThickness);
        await this._delay(60);

        // Tri√°ngulos de c√©sped
        for (let x = 0; x < width; x += coords.grass.triangleSpacing) {
            const height = coords.grass.triangleHeight + (Math.random() * 6 - 3);
            const tipX = x + (Math.random() * 4 - 2);
            const tipY = coords.grass.y - height;
            
            this._sendDrawCommand(x, coords.grass.y, tipX, tipY, this.FIELD_CONSTANTS.GRASS_COLOR, 2);
            this._sendDrawCommand(tipX, tipY, x + coords.grass.triangleSpacing, coords.grass.y, this.FIELD_CONSTANTS.GRASS_COLOR, 2);
            await this._delay(25);
        }
    }

    async _drawGoal(goalCoords, color) {
        const frameThickness = this.FIELD_CONSTANTS.GOAL_THICKNESS;
        const lineThickness = Math.max(1, Math.floor(frameThickness/2));
        const lineMargin = Math.max(8, goalCoords.width * 0.08);
        const topOffset = goalCoords.height * 0.05;

        // Marco principal
        this._sendDrawCommand(goalCoords.x, goalCoords.y, goalCoords.x, goalCoords.y + goalCoords.height, color, frameThickness);
        this._sendDrawCommand(goalCoords.x, goalCoords.y, goalCoords.x + goalCoords.width, goalCoords.y, color, frameThickness);
        this._sendDrawCommand(goalCoords.x + goalCoords.width, goalCoords.y, goalCoords.x + goalCoords.width, goalCoords.y + goalCoords.height, color, frameThickness);
        await this._delay(80);

        // L√≠neas interiores verticales
        for (let i = 1; i <= 3; i++) {
            const x = goalCoords.x + (goalCoords.width * i / 4);
            this._sendDrawCommand(x, goalCoords.y + topOffset, x, goalCoords.y + goalCoords.height - topOffset, color, lineThickness);
            await this._delay(60);
        }

        // L√≠neas interiores horizontales
        for (let i = 1; i <= 4; i++) {
            const y = goalCoords.y + (goalCoords.height * i / 5);
            this._sendDrawCommand(goalCoords.x + lineMargin, y, goalCoords.x + goalCoords.width - lineMargin, y, color, lineThickness);
            await this._delay(60);
        }
    }

    // Patrones de letras para FOOTBALL
    PIXEL_LETTERS = {
        'F': [[1,1,1,1],[1,0,0,0],[1,1,1,0],[1,0,0,0],[1,0,0,0]],
        'O': [[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]],
        'T': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
        'B': [[1,1,1,1],[1,0,0,1],[1,1,1,1],[1,0,0,1],[1,1,1,1]],
        'A': [[0,1,1,0],[1,0,0,1],[1,1,1,1],[1,0,0,1],[1,0,0,1]],
        'L': [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,1,1,1]]
    };

    async _drawFootballText(coords) {
        const text = "FOOTBALL";
        const letterSpacing = coords.text.pixelSize * 6;
        const textWidth = text.length * letterSpacing;
        let currentX = coords.text.x - (textWidth / 2);

        for (let i = 0; i < text.length; i++) {
            const letter = text[i].toUpperCase();
            const pattern = this.PIXEL_LETTERS[letter];
            if (!pattern) continue;

            for (let row = 0; row < pattern.length; row++) {
                for (let col = 0; col < pattern[row].length; col++) {
                    if (pattern[row][col] === 1) {
                        const pixelX = currentX + (col * coords.text.pixelSize);
                        const pixelY = coords.text.y + (row * coords.text.pixelSize);
                        this._sendDrawCommand(pixelX, pixelY, pixelX + 1, pixelY + 1, this.FIELD_CONSTANTS.TEXT_COLOR, coords.text.pixelSize);
                        await this._delay(20);
                    }
                }
            }
            currentX += letterSpacing;
            await this._delay(50);
        }
    }

    // ‚úÖ SISTEMA DE MATCH MODE
    toggleMatchMode() {
        const button = this._ui.matchModeToggle;
        const scoreboard = this._ui.scoreboard;

        this.matchMode.active = !this.matchMode.active;

        if (this.matchMode.active) {
            button.style.background = 'linear-gradient(135deg, #ffd700, #ffb347)';
            scoreboard.style.display = 'block';
            this._setupMatchMode();
            this.notify('success', 'üèÜ ¬°Modo partido activado!');
        } else {
            button.style.background = 'linear-gradient(135deg, #9b59b6, #8e44ad)';
            scoreboard.style.display = 'none';
            this._resetMatch();
            this.notify('info', 'üèÜ Modo partido desactivado.');
        }
    }

    async _setupMatchMode() {
        // Crear campo autom√°ticamente
        await this.createFootballField();
        
        // Resetear puntuaciones
        this.matchMode.scores = { p1: 0, p2: 0 };
        this._updateScoreboard();
        
        // Configurar √°rea de juego
        this.matchMode.playArea = {
            leftGoalX: this._canvas.width * -0.05,
            rightGoalX: this._canvas.width * 0.80,
            goalY: this._canvas.height * 0.67,
            goalWidth: this._canvas.width * 0.25,
            goalHeight: this._canvas.height * 0.42
        };
        
        // A√±adir pelota en el centro despu√©s de un delay
        setTimeout(() => {
            this.addBallAtCenter();
        }, 500);
    }

    _resetMatch() {
        this.matchMode.scores = { p1: 0, p2: 0 };
        this._updateScoreboard();
        this.matchMode.goalCooldown = false;
    }

    _updateScoreboard() {
        if (this._ui.scoreP1) this._ui.scoreP1.textContent = this.matchMode.scores.p1;
        if (this._ui.scoreP2) this._ui.scoreP2.textContent = this.matchMode.scores.p2;
    }

    // ‚úÖ DETECCI√ìN DE GOLES
    _checkGoals() {
        if (!this.matchMode.active || this.matchMode.goalCooldown) return;
        
        const playArea = this.matchMode.playArea;
        const extraPadding = this.PHYSICS_CONSTANTS.BALL_RADIUS + 10;
        
        Array.from(this._physicsObjects.values()).forEach(obj => {
            if (obj.type !== 'ball') return;
            
            // Gol P2 (porter√≠a izquierda)
            if (obj.x >= playArea.leftGoalX - extraPadding &&
                obj.x <= playArea.leftGoalX + playArea.goalWidth + extraPadding &&
                obj.y >= playArea.goalY - extraPadding &&
                obj.y <= playArea.goalY + playArea.goalHeight + extraPadding) {
                this._scoreGoal('p2', obj);
            }
            
            // Gol P1 (porter√≠a derecha)
            if (obj.x >= playArea.rightGoalX - extraPadding &&
                obj.x <= playArea.rightGoalX + playArea.goalWidth + extraPadding &&
                obj.y >= playArea.goalY - extraPadding &&
                obj.y <= playArea.goalY + playArea.goalHeight + extraPadding) {
                this._scoreGoal('p1', obj);
            }
        });
    }

    async _scoreGoal(player, ballObject) {
        if (this.matchMode.goalCooldown) return;
        
        this.matchMode.goalCooldown = true;
        this.matchMode.scores[player]++;
        this.gameStats.totalGoals++;
        
        // Actualizar marcador
        this._updateScoreboard();
        
        // Remover la pelota que anot√≥
        this._physicsObjects.delete(ballObject.id);
        
        this.notify("success", `‚öΩ ¬°GOOOOL! ${player.toUpperCase()} anota!`);
        
        // Redibujar campo y a√±adir nueva pelota
        await this.createFootballField();
        
        // Verificar fin de partido
        if (this.matchMode.scores[player] >= this.matchMode.maxGoals) {
            this.notify("success", `üèÜ ¬°${player.toUpperCase()} GANA EL PARTIDO!`);
            setTimeout(() => this._resetMatch(), 3000);
        } else {
            // A√±adir nueva pelota en el centro
            setTimeout(() => this.addBallAtCenter(), 1000);
        }
        
        // Cooldown de 2 segundos
        setTimeout(() => {
            this.matchMode.goalCooldown = false;
        }, 2000);
    }

    // ‚úÖ SISTEMA DE PELOTAS
    addBallAtCenter() {
        if (!this._canvas) {
            this.notify("error", "‚ùå Canvas no disponible.");
            return;
        }

        this._createBall(this._canvas.width / 2, this._canvas.height / 2);
        this.notify('success', '‚öΩ Pelota a√±adida en el centro.');
    }

    _createBall(x, y) {
        const id = `ball_${this._objectIdCounter++}`;
        const ball = {
            id: id,
            type: 'ball',
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 100,
            vy: (Math.random() - 0.5) * 100,
            radius: this.PHYSICS_CONSTANTS.BALL_RADIUS,
            color: this.controls.defaultObjectColor,
            mass: this.PHYSICS_CONSTANTS.BALL_MASS,
            lastRenderX: -9999,
            lastRenderY: -9999
        };
        
        this._physicsObjects.set(id, ball);
        this.gameStats.objectsCreated++;
        return ball;
    }

    // ‚úÖ MOTOR DE F√çSICA
    togglePhysics() {
        if (this._isActive) {
            this._stopPhysicsLoop();
            this._ui.togglePhysicsBtn.textContent = 'üöÄ Launch Physics Engine';
            this._ui.togglePhysicsBtn.style.background = 'linear-gradient(135deg, #3498db, #2980b9)';
            this.notify('info', 'üõë Motor detenido.');
        } else {
            this._startPhysicsLoop();
            this._ui.togglePhysicsBtn.textContent = '‚è∏Ô∏è Stop Physics Engine';
            this._ui.togglePhysicsBtn.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
            this.notify('success', 'üöÄ Motor iniciado.');
        }
    }

    _startPhysicsLoop() {
        if (this._isActive) return;
        this._isActive = true;
        this._lastRenderTime = performance.now();
        this._update(performance.now());
    }

    _stopPhysicsLoop() {
        this._isActive = false;
    }

    _update(currentTime) {
        if (!this._isActive) return;
        
        const deltaTime = (currentTime - this._lastRenderTime) / 1000;
        this._lastRenderTime = currentTime;

        this._updatePhysics(deltaTime);
        this._checkCollisions();
        if (this.matchMode.active) {
            this._checkGoals();
        }
        this._drawObjects();

        requestAnimationFrame(this._update.bind(this));
    }

    _updatePhysics(deltaTime) {
        const gravity = this.PHYSICS_CONSTANTS.GRAVITY;
        const airResistance = this.PHYSICS_CONSTANTS.AIR_RESISTANCE;

        this._physicsObjects.forEach(obj => {
            // Aplicar resistencia del aire
            obj.vx *= (1 - airResistance);
            obj.vy *= (1 - airResistance);
            
            // Aplicar gravedad
            obj.vy += gravity * deltaTime;
            
            // Limitar velocidad m√°xima
            const speed = Math.sqrt(obj.vx ** 2 + obj.vy ** 2);
            if (speed > this.PHYSICS_CONSTANTS.MAX_VELOCITY) {
                const scale = this.PHYSICS_CONSTANTS.MAX_VELOCITY / speed;
                obj.vx *= scale;
                obj.vy *= scale;
            }
            
            // Actualizar posici√≥n
            obj.x += obj.vx * deltaTime;
            obj.y += obj.vy * deltaTime;
        });
    }

    _checkCollisions() {
        const gameWidth = this._canvas.width;
        const gameHeight = this._canvas.height;
        const restitution = this.PHYSICS_CONSTANTS.RESTITUTION_WALL;

        this._physicsObjects.forEach(obj => {
            // Colisiones con bordes
            if (obj.x - obj.radius < 0) {
                obj.velocity = -obj.vx * restitution;
                obj.x = obj.radius;
            }
            if (obj.x + obj.radius > gameWidth) {
                obj.vx = -obj.vx * restitution;
                obj.x = gameWidth - obj.radius;
            }
            if (obj.y - obj.radius < 0) {
                obj.vy = -obj.vy * restitution;
                obj.y = obj.radius;
            }
            if (obj.y + obj.radius > gameHeight) {
                obj.vy = -obj.vy * restitution;
                obj.y = gameHeight - obj.radius;
                obj.vx *= this.PHYSICS_CONSTANTS.FRICTION_GRASS; // Fricci√≥n en el suelo
            }
        });
    }

    _drawObjects() {
        this._physicsObjects.forEach(obj => {
            if (obj.type !== 'ball') return;
            
            const dx = Math.abs(obj.x - obj.lastRenderX);
            const dy = Math.abs(obj.y - obj.lastRenderY);
            
            if (dx > 3 || dy > 3) {
                // Borrar posici√≥n anterior
                if (obj.lastRenderX !== -9999) {
                    this._drawBall(obj.lastRenderX, obj.lastRenderY, obj.radius, '#FFFFFF');
                }
                
                // Dibujar en nueva posici√≥n
                this._drawBall(obj.x, obj.y, obj.radius, obj.color);
                
                obj.lastRenderX = obj.x;
                obj.lastRenderY = obj.y;
            }
        });
    }

    _drawBall(x, y, radius, color) {
        const thickness = radius * 2.5;
        this._sendDrawCommand(x, y, x + 0.1, y + 0.1, color, thickness);
    }

    // ‚úÖ FUNCIONES AUXILIARES
    resetAllObjects() {
        if (this._canvas) {
            this._physicsObjects.forEach(obj => {
                obj.x = this._canvas.width / 2 + (Math.random() - 0.5) * 100;
                obj.y = this._canvas.height / 2 + (Math.random() - 0.5) * 100;
                obj.vx = 0;
                obj.vy = 0;
                obj.lastRenderX = -9999;
                obj.lastRenderY = -9999;
            });
            this.notify('success', 'üîÑ ¬°Objetos reiniciados!');
        }
    }

    clearAllObjects() {
        this._physicsObjects.clear();
        this._cleanCanvas();
        this.notify('info', 'üóëÔ∏è Todos los objetos eliminados.');
    }

    async _cleanCanvas() {
        if (!this._canvas) return;
        
        const clearThickness = 1000;
        const clearColor = '#FFFFFF';
        const steps = 5;

        for (let i = 0; i <= steps; i++) {
            this._sendDrawCommand(0, (i / steps) * this._canvas.height, this._canvas.width, (i / steps) * this._canvas.height, clearColor, clearThickness);
            this._sendDrawCommand((i / steps) * this._canvas.width, 0, (i / steps) * this._canvas.width, this._canvas.height, clearColor, clearThickness);
            await this._delay(20);
        }
        
        // Limpiar canvas local
        if (this._ctx) {
            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        }
    }

    _delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    _startAdvancedStatsMonitoring() {
        this._stopAdvancedStatsMonitoring();
        this._statsInterval = setInterval(() => {
            if (this._ui.objectCount) this._ui.objectCount.textContent = this._physicsObjects.size;
            if (this._ui.goalsCount) this._ui.goalsCount.textContent = this.gameStats.totalGoals;
        }, 1000);
    }

    _stopAdvancedStatsMonitoring() {
        if (this._statsInterval) {
            clearInterval(this._statsInterval);
            this._statsInterval = null;
        }
    }
}
