// --- Sub-Module 5: PatternDrawerTool ---
// Draws various patterns on Drawaria.online, rendering locally and globally.
class PatternDrawerTool extends QBit {
    _canvas = null;
    _ctx = null;
    _drawingActive = false;
    _socketStatus = 'disconnected';
    _executionLine = []; // Stores draw commands in game coordinates (0-100)

    _ui = {}; // UI elements references

    constructor() {
        super("Pattern Drawer", '<i class="fas fa-th-large"></i>'); // Unique name and icon
        this._onStartup();
    }

    _onStartup() {
        this._canvas = document.getElementById('canvas');
        if (this._canvas) {
            this._ctx = this._canvas.getContext('2d');
        } else {
            this.notify("error", "Canvas del juego no encontrado para Pattern Drawer.");
            return;
        }

        this._loadInterface();
        this._setupEventListeners();
        setInterval(() => { // Periodically check and update connection status
            this._updateConnectionStatus(getGameSocket() && getGameSocket().readyState === WebSocket.OPEN ? 'connected' : 'disconnected');
        }, 1000);
        this.notify("info", "Módulo 'Pattern Drawer' cargado.");
    }

    _loadInterface() {
        const container = domMake.Tree("div", { id: `${this.identifier}-container`, class: "module-section" });
        this.htmlElements.section.appendChild(container);

        // Connection Status
        container.appendChild(domMake.Tree("div", { class: "module-section-title" }, ["Estado de Conexión"]));
        const connectionStatusDiv = domMake.Tree("div", {}, [
            domMake.Tree("span", { id: `${this.identifier}-connectionStatus`, class: `module-status-indicator module-status-${this._socketStatus}` }),
            domMake.Tree("span", { id: `${this.identifier}-statusText` }, [this._socketStatus.charAt(0).toUpperCase() + this._socketStatus.slice(1)])
        ]);
        container.appendChild(connectionStatusDiv);

        // Pattern Selector
        container.appendChild(domMake.Tree("div", { class: "module-section-title" }, ["Seleccionar Patrón"]));
        this._ui.patternSelect = domMake.Tree("select", { id: `${this.identifier}-patternSelect`, class: "module-form-control" });
        const patterns = [
            "grid", "zigzag", "spiral", "waves", "circles", "diagonals",
            "star", "crosshatch", "triangles", "dots", "hexagons", "radiance",
            "checkerboard", "swirls", "lattice", "fractal", "arcs", "mosaic",
            "ripples", "vortex"
        ];
        patterns.forEach(p => {
            this._ui.patternSelect.appendChild(domMake.Tree("option", { value: p }, [p.charAt(0).toUpperCase() + p.slice(1)]));
        });
        container.appendChild(this._ui.patternSelect);

        // Drawing Controls Inputs
        container.appendChild(domMake.Tree("div", { class: "module-section-title" }, ["Configuración de Patrón"]));
        const controlsGroup = domMake.Tree("div", { class: "module-btn-group", style: "flex-wrap: wrap;" }); // Using btn-group for grid-like layout
        const addInput = (id, label, type, min, max, value, title) => {
            const input = domMake.Tree("input", { type, id: `${this.identifier}-${id}`, min, max, value, title, class: "module-form-control" });
            this._ui[id.replace(/-/g, '')] = input; // Store reference
            const wrapper = domMake.Tree("div", { style: "flex: 1 1 48%;" }); // Approx half width
            wrapper.appendAll(domMake.Tree("label", { for: `${this.identifier}-${id}` }, [label]), input);
            controlsGroup.appendChild(wrapper);
        };
        addInput("brushsize", "Grosor:", "number", "2", "20", "4", "Tamaño del Pincel");
        addInput("stepsize", "Paso Patrón:", "number", "5", "50", "10", "Tamaño del Paso del Patrón");
        addInput("offsetX", "Offset X:", "number", "-50", "150", "0", "Desplazamiento Horizontal");
        addInput("offsetY", "Offset Y:", "number", "-50", "150", "0", "Desplazamiento Vertical");
        container.appendChild(controlsGroup);

        // Action Buttons
        const actionButtonsDiv = domMake.Tree("div", { class: "module-btn-group" });
        this._ui.startButton = domMake.Button('<i class="fas fa-play-circle"></i> Iniciar');
        this._ui.stopButton = domMake.Button('<i class="fas fa-stop-circle"></i> Detener');
        this._ui.clearButton = domMake.Button('<i class="fas fa-eraser"></i> Limpiar Todo');
        actionButtonsDiv.appendAll(this._ui.startButton, this._ui.stopButton, this._ui.clearButton);
        container.appendChild(actionButtonsDiv);

        this._ui.statusLabel = domMake.Tree("div", { id: `${this.identifier}-status`, class: "worldgen-status" }, ["Estado: Listo."]);
        container.appendChild(this._ui.statusLabel);
    }

    _setupEventListeners() {
        this._ui.startButton.addEventListener('click', () => {
            const pattern = this._ui.patternSelect.value;
            const thickness = parseInt(this._ui.brushsize.value) || 4;
            const stepSize = parseInt(this._ui.stepsize.value) || 10;
            const offset = {
                x: parseInt(this._ui.offsetX.value) || 0,
                y: parseInt(this._ui.offsetY.value) || 0,
            };

            if (isNaN(thickness) || isNaN(stepSize) || isNaN(offset.x) || isNaN(offset.y)) {
                this.notify("warning", "Valores de entrada inválidos.");
                return;
            }

            const socket = getGameSocket();
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                this.notify("error", "No conectado a Drawaria. Por favor, asegúrate de estar en una sala.");
                return;
            }

            this._ui.statusLabel.textContent = `Dibujando ${pattern}...`;
            this._drawPattern(pattern, thickness, stepSize, offset); // Populate executionLine
            this._executePatternDrawing(socket); // Start execution
        });

        this._ui.stopButton.addEventListener('click', () => {
            this._drawingActive = false;
            this._ui.statusLabel.textContent = 'Dibujo detenido por el usuario.';
        });

        this._ui.clearButton.addEventListener('click', async () => {
            const socket = getGameSocket();
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                this.notify("error", "No conectado a Drawaria. Por favor, asegúrate de estar en una sala.");
                return;
            }

            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height); // Clear local canvas immediately

            const clearThickness = 1000;
            const clearColor = '#FFFFFF';
            const steps = 5;

            for (let i = 0; i <= steps; i++) {
                this._sendAndRenderDrawCommand(socket, [0, (i / steps) * 100], [100, (i / steps) * 100], clearColor, clearThickness);
                await this._delay(20);
                this._sendAndRenderDrawCommand(socket, [(i / steps) * 100, 0], [(i / steps) * 100, 100], clearColor, clearThickness);
                await this._delay(20);
            }
            this._ui.statusLabel.textContent = 'Comandos de limpieza de lienzo enviados.';
        });
    }

    _updateConnectionStatus(status) {
        this._socketStatus = status;
        const statusIndicator = document.getElementById(`${this.identifier}-connectionStatus`);
        const statusText = document.getElementById(`${this.identifier}-statusText`);

        if (statusIndicator && statusText) {
            statusIndicator.className = `module-status-indicator module-status-${status}`;
            statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
            // Enable/disable start button based on connection status
            if (this._ui.startButton) {
                this._ui.startButton.disabled = !(status === 'connected');
            }
        }
    }

    _delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    _getRainbowColor(step, totalSteps) {
        if (totalSteps <= 0) return 'hsl(0, 100%, 50%)';
        let hue = (step / totalSteps) * 360;
        return `hsl(${hue}, 100%, 50%)`;
    }

    _clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    _sendAndRenderDrawCommand(socket, start_game_coords, end_game_coords, color, thickness) {
        if (!socket || socket.readyState !== WebSocket.OPEN) {
            this.notify("warning", "WebSocket no conectado. No se puede enviar ni renderizar el comando de dibujo.");
            return false;
        }

        const x1_norm = (start_game_coords[0] / 100);
        const y1_norm = (start_game_coords[1] / 100);
        const x2_norm = (end_game_coords[0] / 100);
        const y2_norm = (end_game_coords[1] / 100);

        // Local rendering
        this._ctx.strokeStyle = color;
        this._ctx.lineWidth = thickness;
        this._ctx.lineCap = 'round';
        this._ctx.lineJoin = 'round';
        this._ctx.beginPath();
        this._ctx.moveTo(x1_norm * this._canvas.width, y1_norm * this._canvas.height);
        this._ctx.lineTo(x2_norm * this._canvas.width, y2_norm * this._canvas.height);
        this._ctx.stroke();

        const command = `42["drawcmd",0,[${x1_norm.toFixed(4)},${y1_norm.toFixed(4)},${x2_norm.toFixed(4)},${y2_norm.toFixed(4)},false,${0 - thickness},"${color}",0,0,{}]]`;
        socket.send(command);
        return true;
    }

    _drawPattern(pattern, thickness, stepSize, offset) {
        this._executionLine = [];
        const canvasWidth = 100, canvasHeight = 100; // Game coordinates 0-100
        let stepCount = 0;

        // Calculate total steps for rainbow coloring (simplified calculation for brevity)
        let totalSteps = 0;
        switch (pattern) {
            case 'grid': totalSteps = Math.ceil(canvasWidth / stepSize) * 2; break;
            case 'zigzag': totalSteps = Math.ceil(canvasWidth / stepSize); break;
            case 'spiral': totalSteps = Math.floor((50 / (stepSize / 2)) * (Math.PI * 2 / 0.3)); break;
            case 'waves': totalSteps = Math.ceil(canvasWidth / stepSize); break;
            case 'circles': totalSteps = Math.floor(50 / stepSize); break;
            case 'diagonals': totalSteps = Math.ceil((canvasWidth + canvasHeight) / stepSize); break;
            case 'star': totalSteps = 16; break;
            case 'crosshatch': totalSteps = Math.ceil((canvasWidth + canvasHeight) / stepSize) * 2; break;
            case 'triangles': totalSteps = Math.ceil(canvasWidth / stepSize) * 2; break;
            case 'dots': totalSteps = Math.ceil(canvasWidth / stepSize) * Math.ceil(canvasHeight / stepSize); break;
            case 'hexagons': totalSteps = Math.ceil(canvasWidth / (stepSize * 1.5)) * Math.ceil(canvasHeight / (stepSize * Math.sqrt(3))); break;
            case 'radiance': totalSteps = 24; break;
            case 'checkerboard': totalSteps = Math.ceil(canvasWidth / stepSize) * Math.ceil(canvasHeight / stepSize) * 2; break;
            case 'swirls': totalSteps = Math.floor((50 / (stepSize / 2)) * (Math.PI * 2 / 0.4)); break;
            case 'lattice': totalSteps = Math.ceil((canvasWidth + canvasHeight) / stepSize) * 2; break;
            case 'fractal': totalSteps = 31; break;
            case 'arcs': totalSteps = Math.ceil(canvasHeight / stepSize) * Math.floor(Math.PI / 0.2); break;
            case 'mosaic': totalSteps = Math.min(100, Math.floor((canvasWidth * canvasHeight) / (stepSize * stepSize))) * 2; break;
            case 'ripples': totalSteps = Math.floor(50 / stepSize) * Math.floor(Math.PI * 2 / 0.2); break;
            case 'vortex': totalSteps = Math.floor(Math.PI * 2 / 0.1); break;
            default: totalSteps = 1;
        }

        if (pattern === 'grid') {
            for (let x = 0; x <= canvasWidth; x += stepSize) {
                this._executionLine.push({
                    pos1: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(0 + offset.y, 0, canvasHeight)],
                    pos2: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(canvasHeight + offset.y, 0, canvasHeight)],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
            }
            for (let y = 0; y <= canvasHeight; y += stepSize) {
                this._executionLine.push({
                    pos1: [this._clamp(0 + offset.x, 0, canvasWidth), this._clamp(y + offset.y, 0, canvasHeight)],
                    pos2: [this._clamp(canvasWidth + offset.x, 0, canvasWidth), this._clamp(y + offset.y, 0, canvasHeight)],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
            }
        } else if (pattern === 'zigzag') {
            let x = 0, y = 0;
            while (x <= canvasWidth) {
                let nextX = Math.min(x + stepSize, canvasWidth);
                let nextY = (y === 0) ? canvasHeight : 0;
                this._executionLine.push({
                    pos1: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(y + offset.y, 0, canvasHeight)],
                    pos2: [this._clamp(nextX + offset.x, 0, canvasWidth), this._clamp(nextY + offset.y, 0, canvasHeight)],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
                x = nextX;
                y = nextY;
                if (x === canvasWidth && y === 0) {
                    this._executionLine.push({
                        pos1: [this._clamp(canvasWidth + offset.x, 0, canvasWidth), this._clamp(0 + offset.y, 0, canvasHeight)],
                        pos2: [this._clamp(canvasWidth + offset.x, 0, canvasWidth), this._clamp(canvasHeight + offset.y, 0, canvasHeight)],
                        color: this._getRainbowColor(stepCount++, totalSteps),
                        thickness: thickness
                    });
                }
            }
        } else if (pattern === 'spiral') {
            let centerX = canvasWidth / 2 + offset.x;
            let centerY = canvasHeight / 2 + offset.y;
            let maxRadius = 50;
            let angleStep = 0.3;
            for (let r = 5; r <= maxRadius; r += stepSize / 2) {
                for (let a = 0; a < Math.PI * 2; a += angleStep) {
                    let x1 = centerX + r * Math.cos(a);
                    let y1 = centerY + r * Math.sin(a);
                    let x2 = centerX + r * Math.cos(a + angleStep);
                    let y2 = centerY + r * Math.sin(a + angleStep);
                    this._executionLine.push({
                        pos1: [this._clamp(x1, 0, canvasWidth), this._clamp(y1, 0, canvasHeight)],
                        pos2: [this._clamp(x2, 0, canvasWidth), this._clamp(y2, 0, canvasHeight)],
                        color: this._getRainbowColor(stepCount++, totalSteps),
                        thickness: thickness
                    });
                }
            }
        } else if (pattern === 'waves') {
            let amplitude = 15;
            let frequency = 0.05;
            for (let x = 0; x <= canvasWidth; x += stepSize) {
                let y1 = canvasHeight / 2 + amplitude * Math.sin(x * frequency) + offset.y;
                let y2 = canvasHeight / 2 + amplitude * Math.sin(Math.min(x + stepSize, canvasWidth) * frequency) + offset.y;
                this._executionLine.push({
                    pos1: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(y1, 0, canvasHeight)],
                    pos2: [this._clamp(Math.min(x + stepSize, canvasWidth) + offset.x, 0, canvasWidth), this._clamp(y2, 0, canvasHeight)],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
            }
        } else if (pattern === 'circles') {
            let centerX = canvasWidth / 2 + offset.x;
            let centerY = canvasHeight / 2 + offset.y;
            let maxRadius = 50;
            for (let r = stepSize; r <= maxRadius; r += stepSize) {
                for (let a = 0; a < Math.PI * 2; a += 0.2) {
                    let x1 = centerX + r * Math.cos(a);
                    let y1 = centerY + r * Math.sin(a);
                    let x2 = centerX + r * Math.cos(a + 0.2);
                    let y2 = centerY + r * Math.sin(a + 0.2);
                    this._executionLine.push({
                        pos1: [this._clamp(x1, 0, canvasWidth), this._clamp(y1, 0, canvasHeight)],
                        pos2: [this._clamp(x2, 0, canvasWidth), this._clamp(y2, 0, canvasHeight)],
                        color: this._getRainbowColor(stepCount++, totalSteps),
                        thickness: thickness
                    });
                }
            }
        } else if (pattern === 'diagonals') {
            for (let i = -(canvasHeight); i <= canvasWidth; i += stepSize) {
                let x1 = i, y1 = 0;
                let x2 = i + canvasHeight, y2 = canvasHeight;

                let startX = this._clamp(x1 + offset.x, 0, canvasWidth);
                let startY = this._clamp(y1 + offset.y, 0, canvasHeight);
                let endX = this._clamp(x2 + offset.x, 0, canvasWidth);
                let endY = this._clamp(y2 + offset.y, 0, canvasHeight);

                if (x1 < 0 && startY > 0) startX = (startY - offset.y) + offset.x;
                if (x2 > canvasWidth && endY < canvasHeight) endX = (endY - offset.y) + offset.x;

                this._executionLine.push({
                    pos1: [startX, startY],
                    pos2: [endX, endY],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
            }
        } else if (pattern === 'star') {
            let centerX = canvasWidth / 2 + offset.x;
            let centerY = canvasHeight / 2 + offset.y;
            let radius = 50;
            for (let a = 0; a < Math.PI * 2; a += Math.PI / 8) {
                let x = centerX + radius * Math.cos(a);
                let y = centerY + radius * Math.sin(a);
                this._executionLine.push({
                    pos1: [this._clamp(centerX, 0, canvasWidth), this._clamp(centerY, 0, canvasHeight)],
                    pos2: [this._clamp(x, 0, canvasWidth), this._clamp(y, 0, canvasHeight)],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
            }
        } else if (pattern === 'crosshatch') {
            for (let i = -canvasHeight; i <= canvasWidth; i += stepSize) {
                let x1 = i, y1 = 0;
                let x2 = i + canvasHeight, y2 = canvasHeight;

                let startX = this._clamp(x1 + offset.x, 0, canvasWidth);
                let startY = this._clamp(y1 + offset.y, 0, canvasHeight);
                let endX = this._clamp(x2 + offset.x, 0, canvasWidth);
                let endY = this._clamp(y2 + offset.y, 0, canvasHeight);

                if (x1 < 0 && startY > 0) startX = (startY - offset.y) + offset.x;
                if (x2 > canvasWidth && endY < canvasHeight) endX = (endY - offset.y) + offset.x;

                this._executionLine.push({
                    pos1: [startX, startY],
                    pos2: [endX, endY],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
            }
            for (let i = 0; i <= canvasWidth + canvasHeight; i += stepSize) {
                let x1 = canvasWidth, y1 = i;
                let x2 = 0, y2 = i - canvasWidth;

                let startX = this._clamp(x1 + offset.x, 0, canvasWidth);
                let startY = this._clamp(y1 + offset.y, 0, canvasHeight);
                let endX = this._clamp(x2 + offset.x, 0, canvasWidth);
                let endY = this._clamp(y2 + offset.y, 0, canvasHeight);

                if (y1 > canvasHeight && startX < canvasWidth) startX = canvasWidth - (startY - offset.y - canvasHeight);
                if (y2 < 0 && endX > 0) endX = (endY - offset.y);

                this._executionLine.push({
                    pos1: [startX, startY],
                    pos2: [endX, endY],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
            }
        } else if (pattern === 'triangles') {
            for (let y = 0; y <= canvasHeight; y += stepSize * Math.sqrt(3)) {
                for (let x = 0; x <= canvasWidth; x += stepSize * 2) {
                    let p1_up = [x, y + stepSize * Math.sqrt(3)];
                    let p2_up = [x + stepSize, y];
                    let p3_up = [x + stepSize * 2, y + stepSize * Math.sqrt(3)];
                    this._executionLine.push({ pos1: [this._clamp(p1_up[0] + offset.x, 0, canvasWidth), this._clamp(p1_up[1] + offset.y, 0, canvasHeight)], pos2: [this._clamp(p2_up[0] + offset.x, 0, canvasWidth), this._clamp(p2_up[1] + offset.y, 0, canvasHeight)], color: this._getRainbowColor(stepCount++, totalSteps), thickness: thickness });
                    this._executionLine.push({ pos1: [this._clamp(p2_up[0] + offset.x, 0, canvasWidth), this._clamp(p2_up[1] + offset.y, 0, canvasHeight)], pos2: [this._clamp(p3_up[0] + offset.x, 0, canvasWidth), this._clamp(p3_up[1] + offset.y, 0, canvasHeight)], color: this._getRainbowColor(stepCount++, totalSteps), thickness: thickness });
                    this._executionLine.push({ pos1: [this._clamp(p3_up[0] + offset.x, 0, canvasWidth), this._clamp(p3_up[1] + offset.y, 0, canvasHeight)], pos2: [this._clamp(p1_up[0] + offset.x, 0, canvasWidth), this._clamp(p1_up[1] + offset.y, 0, canvasHeight)], color: this._getRainbowColor(stepCount++, totalSteps), thickness: thickness });

                    let p1_down = [x + stepSize, y + stepSize * Math.sqrt(3)];
                    let p2_down = [x + stepSize * 1.5, y + stepSize * Math.sqrt(3) * 1.5];
                    let p3_down = [x + stepSize * 0.5, y + stepSize * Math.sqrt(3) * 1.5];
                    this._executionLine.push({ pos1: [this._clamp(p1_down[0] + offset.x, 0, canvasWidth), this._clamp(p1_down[1] + offset.y, 0, canvasHeight)], pos2: [this._clamp(p2_down[0] + offset.x, 0, canvasWidth), this._clamp(p2_down[1] + offset.y, 0, canvasHeight)], color: this._getRainbowColor(stepCount++, totalSteps), thickness: thickness });
                    this._executionLine.push({ pos1: [this._clamp(p2_down[0] + offset.x, 0, canvasWidth), this._clamp(p2_down[1] + offset.y, 0, canvasHeight)], pos2: [this._clamp(p3_down[0] + offset.x, 0, canvasWidth), this._clamp(p3_down[1] + offset.y, 0, canvasHeight)], color: this._getRainbowColor(stepCount++, totalSteps), thickness: thickness });
                    this._executionLine.push({ pos1: [this._clamp(p3_down[0] + offset.x, 0, canvasWidth), this._clamp(p3_down[1] + offset.y, 0, canvasHeight)], pos2: [this._clamp(p1_down[0] + offset.x, 0, canvasWidth), this._clamp(p1_down[1] + offset.y, 0, canvasHeight)], color: this._getRainbowColor(stepCount++, totalSteps), thickness: thickness });
                }
            }
        } else if (pattern === 'dots') {
            for (let x = 0; x <= canvasWidth; x += stepSize) {
                for (let y = 0; y <= canvasHeight; y += stepSize) {
                    this._executionLine.push({
                        pos1: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(y + offset.y, 0, canvasHeight)],
                        pos2: [this._clamp(x + offset.x + 0.1, 0, canvasWidth), this._clamp(y + offset.y + 0.1, 0, canvasHeight)],
                        color: this._getRainbowColor(stepCount++, totalSteps),
                        thickness: thickness
                    });
                }
            }
        } else if (pattern === 'hexagons') {
            let hexSize = stepSize;
            let hexWidth = hexSize * 1.5;
            let hexHeight = hexSize * Math.sqrt(3);
            for (let y = 0; y < canvasHeight + hexHeight; y += hexHeight) {
                for (let x = 0; x < canvasWidth + hexWidth; x += hexWidth) {
                    let offsetX_row = (Math.floor(y / hexHeight) % 2 === 0) ? 0 : hexWidth / 2;
                    let points = [
                        [x + offsetX_row, y + hexSize / 2],
                        [x + offsetX_row + hexSize / 2, y],
                        [x + offsetX_row + hexSize * 1.5, y],
                        [x + offsetX_row + hexSize * 2, y + hexSize / 2],
                        [x + offsetX_row + hexSize * 1.5, y + hexSize * 1.5],
                        [x + offsetX_row + hexSize / 2, y + hexSize * 1.5]
                    ];
                    for (let i = 0; i < 6; i++) {
                        let p1 = points[i];
                        let p2 = points[(i + 1) % 6];
                        this._executionLine.push({
                            pos1: [this._clamp(p1[0] + offset.x, 0, canvasWidth), this._clamp(p1[1] + offset.y, 0, canvasHeight)],
                            pos2: [this._clamp(p2[0] + offset.x, 0, canvasWidth), this._clamp(p2[1] + offset.y, 0, canvasHeight)],
                            color: this._getRainbowColor(stepCount++, totalSteps),
                            thickness: thickness
                        });
                    }
                }
            }
        } else if (pattern === 'radiance') {
            let centerX = canvasWidth / 2 + offset.x;
            let centerY = canvasHeight / 2 + offset.y;
            let radius = Math.min(centerX, centerY, canvasWidth - centerX, canvasHeight - centerY);
            let numLines = 24;
            for (let i = 0; i < numLines; i++) {
                let angle = (i / numLines) * Math.PI * 2;
                let endX = centerX + radius * Math.cos(angle);
                let endY = centerY + radius * Math.sin(angle);
                this._executionLine.push({
                    pos1: [this._clamp(centerX, 0, canvasWidth), this._clamp(centerY, 0, canvasHeight)],
                    pos2: [this._clamp(endX, 0, canvasWidth), this._clamp(endY, 0, canvasHeight)],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
            }
        } else if (pattern === 'checkerboard') {
            for (let y = 0; y < canvasHeight; y += stepSize) {
                for (let x = 0; x < canvasWidth; x += stepSize) {
                    if ((Math.floor(x / stepSize) + Math.floor(y / stepSize)) % 2 === 0) {
                        this._executionLine.push({ pos1: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(y + offset.y, 0, canvasHeight)], pos2: [this._clamp(x + stepSize + offset.x, 0, canvasWidth), this._clamp(y + offset.y, 0, canvasHeight)], color: this._getRainbowColor(stepCount++, totalSteps), thickness: thickness });
                        this._executionLine.push({ pos1: [this._clamp(x + stepSize + offset.x, 0, canvasWidth), this._clamp(y + offset.y, 0, canvasHeight)], pos2: [this._clamp(x + stepSize + offset.x, 0, canvasWidth), this._clamp(y + stepSize + offset.y, 0, canvasHeight)], color: this._getRainbowColor(stepCount++, totalSteps), thickness: thickness });
                        this._executionLine.push({ pos1: [this._clamp(x + stepSize + offset.x, 0, canvasWidth), this._clamp(y + stepSize + offset.y, 0, canvasHeight)], pos2: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(y + stepSize + offset.y, 0, canvasHeight)], color: this._getRainbowColor(stepCount++, totalSteps), thickness: thickness });
                        this._executionLine.push({ pos1: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(y + stepSize + offset.y, 0, canvasHeight)], pos2: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(y + offset.y, 0, canvasHeight)], color: this._getRainbowColor(stepCount++, totalSteps), thickness: thickness });
                    }
                }
            }
        } else if (pattern === 'swirls') {
            let centerX = canvasWidth / 2 + offset.x;
            let centerY = canvasHeight / 2 + offset.y;
            let maxRadius = 50;
            let angleStep = 0.4;
            for (let r = 5; r <= maxRadius; r += stepSize / 2) {
                for (let a = 0; a < Math.PI * 2; a += angleStep) {
                    let swirl = 5 * Math.sin(r * 0.1);
                    let x1 = centerX + (r + swirl) * Math.cos(a);
                    let y1 = centerY + (r + swirl) * Math.sin(a);
                    let x2 = centerX + (r + swirl) * Math.cos(a + angleStep);
                    let y2 = centerY + (r + swirl) * Math.sin(a + angleStep);
                    this._executionLine.push({
                        pos1: [this._clamp(x1, 0, canvasWidth), this._clamp(y1, 0, canvasHeight)],
                        pos2: [this._clamp(x2, 0, canvasWidth), this._clamp(y2, 0, canvasHeight)],
                        color: this._getRainbowColor(stepCount++, totalSteps),
                        thickness: thickness
                    });
                }
            }
        } else if (pattern === 'lattice') {
            for (let y = 0; y <= canvasHeight; y += stepSize) {
                this._executionLine.push({
                    pos1: [this._clamp(0 + offset.x, 0, canvasWidth), this._clamp(y + offset.y, 0, canvasHeight)],
                    pos2: [this._clamp(canvasWidth + offset.x, 0, canvasWidth), this._clamp(y + offset.y, 0, canvasHeight)],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
            }
            for (let x = 0; x <= canvasWidth; x += stepSize) {
                this._executionLine.push({
                    pos1: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(0 + offset.y, 0, canvasHeight)],
                    pos2: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(canvasHeight + offset.y, 0, canvasHeight)],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
            }
        } else if (pattern === 'fractal') {
            const drawBranch = (x, y, length, angle, depth) => {
                if (depth === 0) return;
                let x2 = x + length * Math.cos(angle);
                let y2 = y - length * Math.sin(angle);
                this._executionLine.push({
                    pos1: [this._clamp(x + offset.x, 0, canvasWidth), this._clamp(y + offset.y, 0, canvasHeight)],
                    pos2: [this._clamp(x2 + offset.x, 0, canvasWidth), this._clamp(y2 + offset.y, 0, canvasHeight)],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
                drawBranch(x2, y2, length * 0.7, angle + Math.PI / 4, depth - 1);
                drawBranch(x2, y2, length * 0.7, angle - Math.PI / 4, depth - 1);
            };
            drawBranch(canvasWidth / 2, canvasHeight, stepSize * 2, Math.PI / 2, 4);
        } else if (pattern === 'arcs') {
            let numArcs = Math.floor(canvasHeight / stepSize);
            for (let i = 0; i < numArcs; i++) {
                let y = i * stepSize + offset.y;
                let centerX = canvasWidth / 2 + offset.x;
                let radius = canvasWidth / 2;
                for (let a = 0; a <= Math.PI; a += 0.1) {
                    let x1 = centerX + radius * Math.cos(a);
                    let y1 = y + radius * Math.sin(a);
                    let x2 = centerX + radius * Math.cos(a + 0.1);
                    let y2 = y + radius * Math.sin(a + 0.1);
                    this._executionLine.push({
                        pos1: [this._clamp(x1, 0, canvasWidth), this._clamp(y1, 0, canvasHeight)],
                        pos2: [this._clamp(x2, 0, canvasWidth), this._clamp(y2, 0, canvasHeight)],
                        color: this._getRainbowColor(stepCount++, totalSteps),
                        thickness: thickness
                    });
                }
            }
        } else if (pattern === 'mosaic') {
            let squareSize = stepSize;
            for (let y = 0; y < canvasHeight; y += squareSize) {
                for (let x = 0; x < canvasWidth; x += squareSize) {
                    let startX_inner = x + Math.random() * squareSize;
                    let startY_inner = y + Math.random() * squareSize;
                    let endX_inner = x + Math.random() * squareSize;
                    let endY_inner = y + Math.random() * squareSize;
                    this._executionLine.push({
                        pos1: [this._clamp(startX_inner + offset.x, 0, canvasWidth), this._clamp(startY_inner + offset.y, 0, canvasHeight)],
                        pos2: [this._clamp(endX_inner + offset.x, 0, canvasWidth), this._clamp(endY_inner + offset.y, 0, canvasHeight)],
                        color: this._getRainbowColor(stepCount++, totalSteps),
                        thickness: thickness
                    });
                }
            }
        } else if (pattern === 'ripples') {
            let centerX = canvasWidth / 2 + offset.x;
            let centerY = canvasHeight / 2 + offset.y;
            let maxRadius = 50;
            let rippleAmplitude = 5;
            for (let r = stepSize; r <= maxRadius; r += stepSize) {
                for (let a = 0; a < Math.PI * 2; a += 0.2) {
                    let currentRadius = r + rippleAmplitude * Math.sin(a * 5);
                    let x1 = centerX + currentRadius * Math.cos(a);
                    let y1 = centerY + currentRadius * Math.sin(a);
                    let x2 = centerX + currentRadius * Math.cos(a + 0.2);
                    let y2 = centerY + currentRadius * Math.sin(a + 0.2);
                    this._executionLine.push({
                        pos1: [this._clamp(x1, 0, canvasWidth), this._clamp(y1, 0, canvasHeight)],
                        pos2: [this._clamp(x2, 0, canvasWidth), this._clamp(y2, 0, canvasHeight)],
                        color: this._getRainbowColor(stepCount++, totalSteps),
                        thickness: thickness
                    });
                }
            }
        } else if (pattern === 'vortex') {
            let centerX = canvasWidth / 2 + offset.x;
            let centerY = canvasHeight / 2 + offset.y;
            let maxRadius = 50;
            let angleStep = 0.1;
            let spiralTightness = 0.05;
            for (let i = 0; i < maxRadius / (stepSize / 4); i++) {
                let r = maxRadius - (i * stepSize / 4);
                if (r < 0) r = 0;
                let currentAngle = i * angleStep + spiralTightness * i;
                let x1 = centerX + r * Math.cos(currentAngle);
                let y1 = centerY + r * Math.sin(currentAngle);
                let x2 = centerX + (r - stepSize / 4) * Math.cos(currentAngle + angleStep + spiralTightness);
                let y2 = centerY + (r - stepSize / 4) * Math.sin(currentAngle + angleStep + spiralTightness);
                this._executionLine.push({
                    pos1: [this._clamp(x1, 0, canvasWidth), this._clamp(y1, 0, canvasHeight)],
                    pos2: [this._clamp(x2, 0, canvasWidth), this._clamp(y2, 0, canvasHeight)],
                    color: this._getRainbowColor(stepCount++, totalSteps),
                    thickness: thickness
                });
            }
        }
    }

    async _executePatternDrawing(socket) {
        if (!socket || socket.readyState !== WebSocket.OPEN) {
            this.notify("error", "Error: Not connected to Drawaria room.");
            return;
        }

        this._drawingActive = true;
        for (let i = 0; i < this._executionLine.length; i++) {
            if (!this._drawingActive) {
                this.notify("info", 'Dibujo detenido.');
                return;
            }
            let currentLine = this._executionLine[i];
            let p1 = currentLine.pos1,
                p2 = currentLine.pos2,
                color = currentLine.color,
                thickness = currentLine.thickness;

            this._sendAndRenderDrawCommand(socket, p1, p2, color, thickness);
            await this._delay(50);
        }
        this._drawingActive = false;
        this.notify("success", 'Dibujo completado.');
    }
}
